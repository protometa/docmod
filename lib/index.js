// Generated by CoffeeScript 1.7.1

/*

DOCMOD
 */

(function() {
  var Q, compile, each, exports, fs, getDoc, jade, layout, link, linkAndLoad, load, md, opt, p, render, request, strm, u, util, yaml;

  fs = require('fs');

  strm = require('stream');

  p = require('path');

  u = require('url');

  util = require('util');

  yaml = require('js-yaml');

  request = require('request');

  each = require('each-async');

  Q = require('q');

  jade = require('jade');

  md = require('marked');

  require('obj-uber');

  opt = {
    src: './src',
    out: './out',
    maxDepth: 4,
    filter: function(doc, req) {
      if (doc.published != null) {
        return doc.published;
      } else {
        return true;
      }
    }
  };

  module.exports = exports = function(arg) {
    opt = arg.uber(opt);
    return function(req, res, next) {
      return compile(req).then(function(doc) {
        if (doc == null) {
          return next();
        } else {
          return res.send(doc);
        }
      }).fail(function(err) {
        return next(err);
      });
    };
  };

  exports.compile = compile = function(req, overridepath) {
    var i, locals, loopLayout, path, srcPath, url;
    url = u.parse(req.url);
    path = overridepath != null ? overridepath : url.pathname;
    srcPath = p.resolve('.', p.join(opt.src, 'docs', path));
    locals = {
      site: opt.site,
      url: url.pathname
    };
    i = 0;
    return getDoc(srcPath).then(function(meta) {
      return linkAndLoad(req, meta, srcPath);
    }).then(function(meta) {
      locals.uber(meta);
      if (locals.body != null) {
        locals.body = md(locals.body);
      }
      if (locals.template != null) {
        return render(locals);
      } else {
        return locals;
      }
    }).then(loopLayout = function(locals) {
      i++;
      if (i > opt.maxDepth) {
        throw new Error('Max layout depth exceeded');
      }
      return Q.when(locals).then(function(locals) {
        if (locals.layout != null) {
          return loopLayout(layout(req, locals));
        } else {
          return locals;
        }
      });
    }).then(function(locals) {
      if (!opt.filter(locals, req)) {
        return null;
      }
      if (locals.content != null) {
        return locals.content;
      } else {
        return locals;
      }
    }).fail(function(err) {
      if (err.code === 'ENOENT' || err.code === 'ENOTDIR') {
        return null;
      } else {
        throw err;
      }
    });
  };

  getDoc = function(path) {
    var d, trypath;
    d = Q.defer();
    if (path == null) {
      d.resolve(null);
    }
    trypath = path + '.yaml';
    fs.readFile(trypath, 'utf8', function(err, data) {
      var doc;
      if (err) {
        if (err.code === 'ENOENT') {
          trypath = p.join(path, 'index.yaml');
          return fs.readFile(trypath, 'utf8', function(err, data) {
            var doc;
            if (err) {
              return d.reject(err);
            } else {
              doc = yaml.safeLoad(data);
              doc.isindex = true;
              return d.resolve(doc);
            }
          });
        } else {
          return d.reject(err);
        }
      } else {
        doc = yaml.safeLoad(data);
        return d.resolve(doc);
      }
    });
    return d.promise;
  };

  linkAndLoad = function(req, locals, path, isindex) {
    var d;
    if (typeof locals !== 'object') {
      throw new Error('Locals (' + locals + ') is not an object');
    }
    if (isindex == null) {
      isindex = locals.isindex;
    }
    d = Q.defer();
    each(Object.keys(locals), function(key, i, done) {
      var newProp, prop, rs;
      prop = locals[key];
      if (prop.hasOwnProperty('$link')) {
        locals[key] = link(req, prop.$link, isindex);
        return done();
      } else if (prop.hasOwnProperty('$load')) {
        newProp = '';
        return rs = load(req, prop.$load, path, isindex).on('data', function(data) {
          return newProp += data;
        }).on('end', function() {
          var _ref, _ref1;
          if ((_ref = rs.response) != null ? (_ref1 = _ref.headers['content-type']) != null ? _ref1.match(/application\/json/) : void 0 : void 0) {
            locals[key] = JSON.parse(newProp);
          } else {
            locals[key] = newProp.toString();
          }
          return done();
        }).on('error', done);
      } else if (typeof prop === 'object') {
        return linkAndLoad(req, prop, path, isindex).then(function() {
          return done();
        }).fail(function(err) {
          return done(err);
        });
      } else {
        return done();
      }
    }, function(err) {
      if (err) {
        return d.reject(err);
      }
      return d.resolve(locals);
    });
    return d.promise;
  };

  link = function(req, arg, isindex) {
    var opturl, pathname, reqopt, reqpath, requrl;
    reqopt = {};
    if (typeof arg === 'string') {
      reqopt.url = arg;
    } else {
      reqopt = arg;
    }
    requrl = u.parse(req.url);
    opturl = u.parse(reqopt.url);
    reqpath = reqopt.url;
    if (opturl.hostname == null) {
      if (opturl.pathname[0] === '/') {
        reqpath = reqopt.url;
      } else {
        pathname = requrl.pathname;
        if (!isindex) {
          pathname = requrl.pathname;
          pathname = pathname.split('/');
          pathname = pathname.slice(0, pathname.length - 1).join('/');
        }
        reqpath = p.join(pathname, reqopt.url);
      }
    }
    return reqpath;
  };

  load = function(req, arg, callpath, isindex) {
    var opturl, pathname, reqopt, requrl;
    reqopt = {};
    if (typeof arg === 'string') {
      reqopt.url = arg;
    } else {
      reqopt = arg;
      if (reqopt.qs == null) {
        reqopt.qs = reqopt.query;
      }
    }
    requrl = u.parse(req.url);
    opturl = u.parse(reqopt.url);
    pathname = opturl.pathname;
    if (opturl.hostname == null) {
      if (opturl.pathname[0] !== '/') {
        if (callpath != null) {
          if (isindex) {
            pathname = p.join(callpath, reqopt.url);
          } else {
            callpath = callpath.split('/');
            callpath = callpath.slice(0, callpath.length - 1).join('/');
            pathname = p.join(callpath, reqopt.url);
          }
          return fs.createReadStream(pathname, {
            encoding: 'utf8'
          });
        } else {
          pathname = p.join(opturl.pathname, reqopt.url);
        }
      }
      reqopt.url = u.format({
        protocol: 'http:',
        hostname: 'localhost',
        port: req.socket.localPort,
        pathname: pathname,
        search: requrl.query
      });
    }
    if (reqopt.headers == null) {
      reqopt.headers = {
        'accept-encoding': null
      };
    }
    return req.pipe(request(reqopt));
  };

  layout = function(req, locals) {
    var srcPath;
    if (locals.content == null) {
      locals.content = locals.body;
    }
    srcPath = p.resolve('.', p.join(opt.src, 'layouts', locals.layout));
    return getDoc(srcPath).then(function(meta) {
      return linkAndLoad(req, meta, srcPath);
    }).then(function(meta) {
      debugger;
      delete locals.layout;
      locals.uber(meta);
      if (locals.template != null) {
        return render(locals);
      } else {
        return locals;
      }
    });
  };

  render = function(locals) {
    locals.basedir = p.resolve('.', p.join(opt.src, 'layouts'));
    return Q.nfcall(jade.render, locals.template, locals).then(function(rendered) {
      locals.content = rendered;
      delete locals.template;
      return locals;
    });
  };

}).call(this);
